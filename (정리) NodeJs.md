# Node.js

## # 특징
	
	* CommonJS 표준을 따른다.
	* 이벤트 루프 기반의 비동기 I/O
	* 노드의 모든 I/O는 논 블록킹 I/O다 
	* 싱글 스레드, 싱글 스텍 사용 
		- 동시성에 대한 고민을 할 필요가 없음
		- 멀티 스레드에 비하여 훨씬 적은 메모리와 시스템 자원을 소모한다. 
		- 사용자 코드를 처리하는 스레드가 단 하나다. 전체 스레드가 하나라는 의미는 아님
		- 단점 : 현재 스레드가 처리중인 작업이 CPU 처리량이 많아 오래 걸린다면 다른 이벤트가 처리되지 않는다.
			: 만약 while 문 등으로 무한 루프에 빠지면 이벤트가 발생해도 절대 처리 되지 않는다.
		
		- 싱글 스레드 이므로 스레드를 멈추는 명령이 존재 하지 않는다.
			: 처리할 코드가 없으면 Idle 상태로 있다가 이벤트가 발생히면 콜백 함수를 실행한다.
		
		
		
	* 개발자가 직접 작성한 코드만 싱글 스레드/동기로 동작하고, 그 외 모든 I/O는 비동기로 동작
	
	* 스케일업으로 성능이 크게 향상되지 않는다. 
		- cpu 갯수 , 메모리용량등을 늘리는 하드웨어 성능을 높이는 것으로 성능야 크게 향상되지 않는다
		-> 노드 인스턴스를 어러개 실행해 인스턴사간의 메세지 통신을 통해 해결할 수 있다. 
	
	* 구글크롬 웹브라우저의 V8엔진을 사용
	
## 버전 확인

```
node --version
```

## js 파일 실행 (REPL)

```
node 파일명
```

파일명뒤에 자동으로 .js를 붙여 준다. 

## 하나의 자바스트립트는 하나의 모듈이 된다.
	- 자바스크립트에서 정의한 객체는 모두 외부에서는 접근할 수 없고, 내부에서만 접근이 가능한 지역범위로 정의된다.
	-> 실제로 node는 각 자바스크립트 파일을 function () {} 로 감싸도록 처리한다.
	-> 외부에서 접근을 허용해야 하는 겍채는 명시적으로 지정해야 한다. 
		: module.export
		: 사용하는 파일에서는 require()로 불러와 module.export로 허용된 변수나 함수를 사용한다. 
		
		
## require( 모듈명 )
	: 모듈명이 ./ ../ 등의 상대 경로로 시작하지 않는 경우 
		기본 모듈이나 확장 모듈을 불러온다.
		 
		ex) fs , util , http
		
	: require() 로 호출하면 node 내에 한번만 로드되고 동일한 객체가 계속 리턴된다.
	-> 새로운 객체가 필요한 경우
	: 초기화 함수를 따로 노출 하거나
	: function을 리턴해 new로 인스턴스를 생성해서 사용해야 한다.

	
## export 방법 3가지
```
exports = {};
```
```
exports = something = {};
```
```
module.exports = {};
```

exports 는 module.exports 의 별칭이다. ( ?? 별칭 정의는 어디에서 찾을 수 있는가?)


## Node 웹서버는 기본적으로 Transfer-Encoding 을  chunked로 사용한다.
	: HTTP 규약에 따라 응답 바디가 생성 되자 마자 웹브라우저로 전달된다.
	
	: chunked에 대한 처리는 브라우저에 따라 다른다. 
		: 크롬은 한꺼번에 처리
		: 파폭은 그때 그때 받은 내용을 순차적으로 처리

## 노드 표준 라이브러리는 자바 스크립트로 작성되어 있다.

## 코딩 규칙
	* 동등비교는 == 대신 ===를 사용한다.
	* 콜백함수 : 콜백함수의 첫 파라미터는 에러파라미터로 한다.
	* 콤마로 여러줄에 걸쳐 나열할 때는 콤마를 라인앞에 써준다.

## 전역객체
	브라우저는 window
	Node 는 global : 편의상 global은 생갹가능함
	
----	
## process 객체 	
	
### process는 EventEmitter의 객체이다.
: 이벤트 등록가능

### 프로세스가 종료될때 마지막으로 실행 ( exit , end 이벤트 발생시 처리)
```
process.on( 'exit' , 프로세스가 종료될때 실행할 콜백함수 );
```

: ctrl + c : exit 이벤트 발생
: ctrl + d : end 이벤트 발생 (윈도우에서는 발생하지 않음)


### try-catch 처리되지 않은 예외가 발생하면 최종 실행하고 프로세스 종료
```
process.on( 'uncaughtException', 콜백함수 );
```

: 예외가 발생하기 이전에 등록된 이벤트까지는 마지막으로 처리하고 종료됨
( uncaughtException를 등록하지 않았다면 등록된 이벤트도 처리하지 않고 바로 프로세스가 종료됨.... ) ( TODO 이해 어렵네..)


### 프로세스 실행시 전달받은 모든 파라미터 
: process.argv

: node 명령부터 포함해서 ' '로 구분된 모든 토큰을 배열로 가지고 있음

### cpu연산이 많이 필요한 작업을 비동기로 호출

```
process.netxtTicket( 콜백함수 );
```
: 콜백함수는 바로 실행하지 않고, 이벤트 큐에 등록한다. 싱글 스레드가 현재 작업을 완료하고 다음 이벤트를 처리할 수 있을 때 차례대로 등록된 콜백함수들을 실행한다.


----
## util

### 문자열 포멧팅
```
util.format ( '문자열 %s , JSON %j , 숫자 %d ' , '문자' , { title : '제목 '} , 10 );
```

----

## 이벤트

: 발생한 이벤트는 모두 EventEmitter의 객체이고 , require ('events').EventEmitter 로 접근한다.
: 이벤트 발생을 emit 이라는 단어를 사용하고, 이벤트가 발생했을 때 실행되는 함수를 리스너(listener)라 한다. 
:  EventEmitter 객체에서 에러가 발생하면 error 이벤트가 발생한다.
error 이벤트에 리스너가 등록되어 있으면 리스너를 실행하고 , 리스너가 없다면  스택트레이스를 출력하고 에플리케이션을 종료한다.

: 객체에 이벤트를 추가하려면

* emitter.addListener( event, listener)
혹은 emitter.on ( event , listener ) 를 사용한다.

* event는 문자열로 된 이벤트명임
* 새로운 리스너가 추가될 때 newListener 이벤트 발생시
* 한번만 실행되어야 하는 이벤트는 emitter.once( event, listener ); 로 등록하면 최초 한번만 실행되고 리스너 배열에서 제거 된다. 

* EventEmitter는 한 이벤트에 등록된 리스너가 10개 이상이면 경고 메세지를 출력한다.
: 리스너 갯수제한을 늘리고 싶으면 emitter.setMaxListeners(n)을 사용 , 0 은 무한대 임

## 버퍼

: 옥텟 스트림을 다루는 함수 제공

옥텟 = 8비트로 이루어진 단위 (모든 컴퓨터가 8비트를 1바이트로 사용하지 않기 때문에 8비트로 이루어진 데이터임을 명확히 하기 위해 옥텟 이라는 용어를 사용한다. )

: 자바스크립트는 유니코드에는 적합하지만 바이너리 데이터는 잘 다루지 못한다. 
: 자바스크립트 문자열과 버퍼 사이에 변환을 하려면 인코딩을 지정해야 한다. 
: 

## 클러스터 (cluster)

: 멀티프로세스의 잇점을 얻기 위해 사용

cluster.isMaster : 마스터 클러스터 인지 여부
var worker = cluster.fork() : 워커 프로세스 생성 

var numCPUs = require('os').cpus().lenght : cpu 갯수 

cluster.on('death', function (worker) { ... } ); : 프로세스가 종료 되었을 때 호출
: worker.pid = 프로세스 번호

### worker와 마스터 프로세스와의 통신
	
	process.send ( {객체} ); : 마스터로 메세지 보냄
	
	worker.on('message' , 콜백함수 ) : 마스터에서 message이벤트로 받음
	
: 성능이 확실히 향상 된다.. but 클러스터의 배수만큼 향상되지는 않는다. 
( 클러스터를 2로 잡았을때 14초 => 9초 )


----
	
## 디버깅

### # util 모듈
	
* util.log()  : 시간 출력  
* util.debug() : DEBUG: 를 앞에 표시  
* util.inspect( 객체 , showHidden=false , depth=2 ) : 객체를 출력  
	: showHidden 이 true면 prototype으로 연결된 속성까지 표시  
	: depth는 몇 계층까지 표시할지 , null 무한  


### # clog 확장 모듈을 사용하면 구분하기 쉬운 로그 메세지 사용가능
```
npm install clog
```
```
clog( '커스텀 헤드' , 메세지 );
clog.log()
clog.info()
clog.warn()
clog.error()
clog.debug()
```

### # 노드 인스펙터 ( node-inspector )


#### 설치
```
npm install node-inspector -g
```


#### 실행 절차

##### 1. 노드 프로그램을 디버깅 모드로 실행

: 프로그램 실행 후 대기상태로 있는 프로그램
- 원하는 위치에 중단점을 지정해 디버깅
```
node --debug 파일명
```

: 프로그램 실행 후 바로 종료 되어버리는 프로그램
- 프로그램이 실행하면 첫행에 브레이크 포인트 
```
node --debug-brk 파일명
```

##### 2. 노드 인스펙터 실행

: 노드로 프로그램을 실행시킨 터미널말고 다른 터미널에서 노드인스펙터 실행
```
node-inspector &
```

##### 3. 웹킷 기반의 브라우져(크롬,사파리)로 접속하여 디버깅

http://localhost:8080/

인스펙터 로그에는 http://localhost:8080/debug?port=5858로 나오지만
5858이 기본값 이므로 생략할 수 있다. 


### # 기타 

* 이클립스 
* 웹 IDE인 클라우드9 : http://c9.io







	
----

### 아파치 벤치
```
ab -n 100 -c 100 http://127.0.0.1:3000/
```

리포트중 주목할 부분
* Time taken for test : 벤치마킹 테스트를 하는데 걸린 전체 시간을 의미
		
		
		

----

?? 객체에 대해 정의된 이벤트는 어디에서 찾아 볼 수 있는가?

?? 자바스크립트 클로져(closure) 공부 필요
	

	
	








	